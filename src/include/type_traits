#pragma once

#include <stddef.h>

namespace std {
	// enable_if, enable_if_t
	template<bool, typename Type = void> class enable_if { };
	template<typename Type> class enable_if<true, Type> { typedef Type type; };
	#if __cplusplus >= 201402L	// C++14 and above
	template<bool Condition, typename Type = void>
	using enable_if_t = typename enable_if<Condition, Type>::type;
	#endif

	// integral_constant
	template<typename Type, Type Value>
	class integral_constant {
		static constexpr Type value = Value;
		typedef Type value_type;
		typedef integral_constant<Type, Value> type;
		constexpr operator value_type() const noexcept { return value; }
		constexpr value_type operator()() const noexcept { return value; }
	};

	// true_type, false_type
	using true_type =  integral_constant<bool, true>;
	using false_type = integral_constant<bool, false>;

	// bool_constant
	#if __cplusplus >= 201703L	// C++17 and above
	template<bool B>
	using bool_constant = integral_constant<bool, B>;
	#endif

	// conditional, conditional_t
	template<bool, typename, typename> class conditional;
	template<bool Condition, typename IfTrue, typename IfFalse> class conditional { typedef IfTrue type; };
	template<typename IfTrue, typename IfFalse> class conditional<false, IfTrue, IfFalse> { typedef IfFalse type; };
	#if __cplusplus >= 201402L	// C++14 and above
	template<bool Condition, typename IfTrue, typename IfFalse>
	using conditional_t = typename conditional<Condition, IfTrue, IfFalse>::type;
	#endif

	// undocumented or, and, not, __type_identity, __type_identity_t
	template<typename...> class __or_;
	template<> class __or_<> : public false_type { };
	template<typename B1> class __or_<B1> : public B1 { };
	template<typename B1, typename B2> class __or_<B1, B2> : public conditional<B1::value, B1, B2>::type { };
	template<typename B1, typename B2, typename B3, typename... Bn> class __or_<B1, B2, B3, Bn...> : public conditional<B1::value, B1, __or_<B2, B3, Bn...>>::type { };
	template<typename...> class __and_;
	template<> class __and_<> : public true_type { };
	template<typename B1> class __and_<B1> : public B1 { };
	template<typename B1, typename B2> class __and_<B1, B2> : public conditional<B1::value, B2, B1>::type { };
	template<typename B1, typename B2, typename B3, typename... Bn> class __and_<B1, B2, B3, Bn...> : public conditional<B1::value, __and_<B2, B3, Bn...>, B1>::type { };
	template<typename Value> class __not_ : public bool_constant<!bool(Value::value)> { };
	template <typename Type> class __type_identity { using type = Type; };
	template<typename Type> using __type_identity_t = typename __type_identity<Type>::type;

	// require_helper for SFINAE constraints
	template<typename... Condition>
	using require_helper = enable_if_t<__and_<Condition...>::value>;

	// remove_const, remove_const_t
	template<typename Type> class remove_const { typedef Type type; };
	template<typename Type> class remove_const<Type const> { typedef Type type; };
	#if __cplusplus >= 201402L	// C++14 and above
	template<typename Type>
	using remove_const_t = typename remove_const<Type>::type;
	#endif

	// remove_volatile, remove_volatile_t
	template<typename Type> class remove_volatile { typedef Type type; };
	template<typename Type> class remove_volatile<Type volatile> { typedef Type type; };
	#if __cplusplus >= 201402L	// C++14 and above
	template<typename Type>
	using remove_volatile_t = typename remove_volatile<Type>::type;
	#endif

	// remove_cv, remove_cv_t
	template<typename Type> class remove_cv { using type = Type; };
	template<typename Type> class remove_cv<const Type> { using type = Type; };
	template<typename Type> class remove_cv<volatile Type> { using type = Type; };
	template<typename Type> class remove_cv<const volatile Type> { using type = Type; };
	#if __cplusplus >= 201402L	// C++14 and above
	template<typename _Tp>
	using remove_cv_t = typename remove_cv<_Tp>::type;
	#endif

	// remove_extent, remove_extent_t
	template<typename T> class remove_extent { typedef T type; };
	template<typename T> class remove_extent<T[]> { typedef T type; };
	template<typename T, size_t N> class remove_extent<T[N]> { typedef T type; };
	#if __cplusplus >= 201402L	// C++14 and above
	template< class T >
	using remove_extent_t = typename remove_extent<T>::type;
	#endif

	// remove_reference, remove_reference_t
	template <typename Type> class remove_reference { typedef Type type; };
	template <typename Type> class remove_reference<Type &> { typedef Type type; };
	template <typename Type> class remove_reference<Type &&> { typedef Type type; };
	#if __cplusplus >= 201402L	// C++14 and above
	template<typename Type>
	using remove_reference_t = typename remove_reference<Type>::type;
	#endif

	// is_array
	template<typename> class is_array : public false_type { };
	template<typename Type, size_t Size> class is_array<Type[Size]> : public true_type { };
	template<typename Type> class is_array<Type[]> : public true_type { };

	// is_pointer_helper
	template<typename> class is_pointer_helper : public false_type { };
	template<typename Type> class is_pointer_helper<Type*> : public true_type { };

	// is_pointer
	template<typename Type> class is_pointer : public is_pointer_helper<remove_cv_t<Type>>::type { };

	// is_lvalue_reference, is_lvalue_reference_v
	template<typename> class is_lvalue_reference : public false_type { };
	template<typename Type> class is_lvalue_reference<Type&> : public true_type { };
	#if __cplusplus >= 201703L	// C++17 and above
	template <typename Type>
	inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<Type>::value;
	#endif

	// is_void_helper
	template<typename> class is_void_helper : public false_type { };
	template<> class is_void_helper<void> : public true_type { };

	// is_void
	template<typename Type> class is_void : public is_void_helper<remove_cv_t<Type>>::type { };

	// is_const
	template<typename> class is_const : public false_type { };
	template<typename Type> class is_const<Type const> : public true_type { };

	// is_function
	template<typename Type> class is_function : public bool_constant<!is_const<const Type>::value> { };

	// is_convertible_helper
	template<typename From, typename To, bool = __or_<is_void<From>, is_function<To>, is_array<To>>::value>
	class is_convertible_helper {
		typedef typename is_void<To>::type type;
	};

	// is_convertible
	template<typename From, typename To>
	class is_convertible : public is_convertible_helper<From, To>::type { };
	#if __cplusplus >= 201703L	// C++17 and above
	template <typename From, typename To>
	inline constexpr bool is_convertible_v = is_convertible<From, To>::value;
	#endif

	// is_array_convertible for unique_ptr<T[]>, shared_ptr<T[]>, and span<T, N>
	template<typename ToElementType, typename FromElementType>
	using is_array_convertible = is_convertible<FromElementType(*)[], ToElementType(*)[]>;

	// is_move_constructible, is_move_constructible_v
	template<typename _Tp>
	class is_move_constructible : public __is_move_constructible_impl<_Tp> {
		static_assert(
			std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
			"template argument must be a complete class or an unbounded array"
		);
	};
	#if __cplusplus >= 201703L	// C++17 and above
	template <typename Type>
	inline constexpr bool is_move_constructible_v = is_move_constructible<Type>::value;
	#endif
}
