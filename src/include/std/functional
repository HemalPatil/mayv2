#pragma once

#include <memory>

namespace std {
	// std::function taken from https://shaharmike.com/cpp/naive-std-function
	template <typename T>
	class function;

	template <typename ReturnValue, typename... Args>
	class function<ReturnValue(Args...)> {
	public:
		template <typename T>
		function& operator=(T t) {
			callable_ = std::make_unique<CallableT<T>>(t);
			return *this;
		}

		function& operator=(std::nullptr_t) {
			callable_ = nullptr;
			return *this;
		}

		ReturnValue operator()(Args... args) const {
			if (callable_ == nullptr) {
				// TODO: should throw exception or do something
				return;
			}
			return callable_->Invoke(args...);
		}

		explicit operator bool() const noexcept {
			return callable_ != nullptr;
		}

	private:
		class ICallable {
		public:
			virtual ~ICallable() = default;
			virtual ReturnValue Invoke(Args...) = 0;
		};

		template <typename T>
		class CallableT : public ICallable {
		public:
			CallableT(const T& t)
				: t_(t) {
			}

			~CallableT() override = default;

			ReturnValue Invoke(Args... args) override {
				return t_(args...);
			}

		private:
			T t_;
		};

		std::unique_ptr<ICallable> callable_;
	};
}
